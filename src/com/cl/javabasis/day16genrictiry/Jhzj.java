package com.cl.javabasis.day16genrictiry;

/*
单列集合体系
--------| Collection 单列集合根接口
------------| List接口 有序可重复
----------------| ArrayList 通过Object数组维护，特点：查询快，增删慢
----------------| LinkedList 通过链表维护，特点：查询慢，增删快
----------------| Vector 和ArrayList一样，但是是线程安全的，操作效率低
------------| Set接口 无序不可重复
----------------| HashSet 通过哈希表维护，特点：存取速度快
	HashSet添加元素原理：
		往HashSet添加元素的时候，HashSet会调用该元素的HashCode方法得到该元素的哈希码，用这个哈希码经过一系列的运算得到一个哈希表中的位置，1.如果
		该位置没有元素，则直接存储在该位置，2.如果该位置有元素，那么要调用该元素的equals与该位置的其他元素相比较，如果返回false，则该元素就存在
		该位置，如果返回true，则视为重复元素，不能存储
----------------| TreeSet 通过红黑树（二叉树）进行维护，会对元素进行排序
 	TreeSet要注意：
 		1.往TreeSet添加元素的时候，如果元素本身具备自然排序的特性，那么会根据元素的自然排序的特性进行排序存储
 		2.往TreeSet添加元素的时候，如果元素本身不具备自然排序的特性，那么元素所属的类要实现Comparable接口，实现compareTo方法，定义排序规则
		3.往TreeSet添加元素的时候，如果元素本身不具备自然排序的特性，元素所属类也没有实现Comparable接口，那么要在创建TreeSet时传入一个自定义比较器类
			自定义比较器类实现Comparator接口，实现Comparator接口的compare方法定义比较规则
			class 比较器类名 implements Comparator{}
		4.如果比较方法（CompareTo或Compare）返回的是0，就被视为重复元素，不允许添加
	
		
泛型	 jdk1.5出现的，
自定义泛型：可理解为数据类型变量，如String、Integer等，（不能使用基本数据类型）
泛型的好处：
	1.将运行时异常提前至编译时
	2.减少了无谓的强制类型转换

	
	泛型方法	
		定义格式：修饰符	<声明自定义泛型>返回值类型	方法名(自定义泛型名	变量名...){}
		泛型方法注意：
			1.自定义泛型的具体数据类型是在调用方法时传入实参时确定的
			2.自定义泛型的命名只要符合自定义标识符的命名规则即可，但是我们一般使用T或E
			2.如果调用方法是不指定具体数据类型，则泛型类型为Object类型
	
	泛型类
		定义格式：class 类名<声明自定义泛型>{}
		泛型类要注意:
			1.自定义泛型的具体数据类型是在用该类创建对象时指定具体数据类型的。
			2.如果一个类已经自定义了泛型，使用该类创建对象的时候如果没有指定泛型的具体数据类型，那么默认为Object类型。
			3. 静态的函数不能使用类上自定义的泛型，如果静态函数需要使用，必须要在函数上自定义泛型。
	
	泛型接口
		定义格式：interface 接口名<声明自定义泛型>{}
		泛型接口要注意：
			1.自定义泛型的具体数据类型是在实现该接口的时候指定具体数据类型的
			2.如果实现接口的时候没有指定接口上 的自定义泛型的具体数据类型，那么默认为Object数据类型。
			3.如果想在创建具体对象是再确定泛型具体数据类型，那么需要在接口实现类上声明：class   类名<T>	implements	接口名<T>{}
		
	泛型上下限
		? super Integer 该类只能是Integer或Integer的父类		泛型下限
		? extends Number 该类只能是Number或Number的子类		泛型上限
		
*/
public class Jhzj {

}
